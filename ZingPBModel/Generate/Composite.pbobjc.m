// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: composite.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Composite.pbobjc.h"
 #import "Plain.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ZTMCompositeRoot

@implementation ZTMCompositeRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ZTMCompositeRoot_FileDescriptor

static GPBFileDescriptor *ZTMCompositeRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"zing.model.composite"
                                                 objcPrefix:@"ZTM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ZTMChannel

@implementation ZTMChannel

@dynamic id_p;
@dynamic category;
@dynamic userId;
@dynamic name;
@dynamic icon;
@dynamic description_p;
@dynamic isActive;
@dynamic isVerify;
@dynamic isRecommend;
@dynamic isAnonymous;
@dynamic createAt;
@dynamic updateAt;
@dynamic senseCount;
@dynamic subscribeTimes;
@dynamic updateDescAt;
@dynamic lastPostAt;
@dynamic hasUser, user;
@dynamic hasLayoutConfig, layoutConfig;
@dynamic hasChannelConfig, channelConfig;
@dynamic hasSenseConfig, senseConfig;
@dynamic hasChannelPermission, channelPermission;
@dynamic hasSensePermission, sensePermission;
@dynamic refsArray, refsArray_Count;
@dynamic isFollow;
@dynamic isTopping;
@dynamic unreadSenseCount;
@dynamic ownSenseCount;
@dynamic todayPunchTimes;
@dynamic myAttitude;
@dynamic hasPuch, puch;

typedef struct ZTMChannel__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  int32_t isActive;
  int32_t isVerify;
  int32_t isRecommend;
  int32_t isAnonymous;
  uint32_t createAt;
  uint32_t updateAt;
  int32_t senseCount;
  int32_t subscribeTimes;
  uint32_t updateDescAt;
  uint32_t lastPostAt;
  int32_t isFollow;
  int32_t isTopping;
  int32_t todayPunchTimes;
  int32_t myAttitude;
  NSString *id_p;
  NSString *userId;
  NSString *name;
  NSString *icon;
  NSString *description_p;
  ZTMUserDescription *user;
  ZTMChannelLayoutConfig *layoutConfig;
  ZTMChannelConfig *channelConfig;
  ZTMSenseConfig *senseConfig;
  ZTMChannelPermission *channelPermission;
  ZTMSensePermission *sensePermission;
  NSMutableArray *refsArray;
  NSString *unreadSenseCount;
  NSString *ownSenseCount;
  ZTMPunch *puch;
} ZTMChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_Description_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_IsActive,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isVerify",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_IsVerify,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, isVerify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isRecommend",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_IsRecommend,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, isRecommend),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAnonymous",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_IsAnonymous,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, isAnonymous),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_CreateAt,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "updateAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_UpdateAt,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, updateAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "senseCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_SenseCount,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, senseCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subscribeTimes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_SubscribeTimes,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, subscribeTimes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "updateDescAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_UpdateDescAt,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, updateDescAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "lastPostAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_LastPostAt,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, lastPostAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMChannel_FieldNumber_User,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "layoutConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelLayoutConfig),
        .number = ZTMChannel_FieldNumber_LayoutConfig,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, layoutConfig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelConfig),
        .number = ZTMChannel_FieldNumber_ChannelConfig,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, channelConfig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senseConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSenseConfig),
        .number = ZTMChannel_FieldNumber_SenseConfig,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, senseConfig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelPermission",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelPermission),
        .number = ZTMChannel_FieldNumber_ChannelPermission,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, channelPermission),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sensePermission",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSensePermission),
        .number = ZTMChannel_FieldNumber_SensePermission,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, sensePermission),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "refsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelDescription),
        .number = ZTMChannel_FieldNumber_RefsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, refsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFollow",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_IsFollow,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, isFollow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isTopping",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_IsTopping,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, isTopping),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unreadSenseCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_UnreadSenseCount,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, unreadSenseCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ownSenseCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_OwnSenseCount,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, ownSenseCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "todayPunchTimes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_TodayPunchTimes,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, todayPunchTimes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "myAttitude",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannel_FieldNumber_MyAttitude,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, myAttitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "puch",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMPunch),
        .number = ZTMChannel_FieldNumber_Puch,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(ZTMChannel__storage_, puch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannel class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\026\003\006\000\010\010\000\t\010\000\n\013\000\013\013\000\014\010\000\r\010\000\016\n\000\017\016\000\020\014\000\021\n\000f\014\000g\r\000"
        "h\013\000j\021\000k\017\000m\010\000n\t\000o\020\000p\r\000q\017\000r\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelConfig

@implementation ZTMChannelConfig

@dynamic userIdentitiesArray, userIdentitiesArray_Count;
@dynamic hasVideo, video;
@dynamic hasPunch, punch;
@dynamic hasVote, vote;
@dynamic mediaPageURL;
@dynamic mediaType;

typedef struct ZTMChannelConfig__storage_ {
  uint32_t _has_storage_[1];
  uint32_t mediaType;
  NSMutableArray *userIdentitiesArray;
  ZTMVideoConfig *video;
  ZTMPunchConfig *punch;
  ZTMVoteConfig *vote;
  NSString *mediaPageURL;
} ZTMChannelConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdentitiesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelUserIdentity),
        .number = ZTMChannelConfig_FieldNumber_UserIdentitiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMChannelConfig__storage_, userIdentitiesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMVideoConfig),
        .number = ZTMChannelConfig_FieldNumber_Video,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelConfig__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "punch",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMPunchConfig),
        .number = ZTMChannelConfig_FieldNumber_Punch,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelConfig__storage_, punch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vote",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMVoteConfig),
        .number = ZTMChannelConfig_FieldNumber_Vote,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelConfig__storage_, vote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mediaPageURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelConfig_FieldNumber_MediaPageURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMChannelConfig__storage_, mediaPageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediaType",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelConfig_FieldNumber_MediaType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMChannelConfig__storage_, mediaType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelConfig class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000userIdentities\000\005\n!!\000\024\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelLayoutConfig

@implementation ZTMChannelLayoutConfig

@dynamic hasHead, head;
@dynamic defaultTab;
@dynamic tabsArray, tabsArray_Count;
@dynamic stylesArray, stylesArray_Count;

typedef struct ZTMChannelLayoutConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t defaultTab;
  ZTMChannelViewHead *head;
  NSMutableArray *tabsArray;
  NSMutableArray *stylesArray;
} ZTMChannelLayoutConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "head",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelViewHead),
        .number = ZTMChannelLayoutConfig_FieldNumber_Head,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelLayoutConfig__storage_, head),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "defaultTab",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelLayoutConfig_FieldNumber_DefaultTab,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelLayoutConfig__storage_, defaultTab),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tabsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelViewTab),
        .number = ZTMChannelLayoutConfig_FieldNumber_TabsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMChannelLayoutConfig__storage_, tabsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stylesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelViewStyle),
        .number = ZTMChannelLayoutConfig_FieldNumber_StylesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMChannelLayoutConfig__storage_, stylesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelLayoutConfig class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelLayoutConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSense

@implementation ZTMSense

@dynamic id_p;
@dynamic category;
@dynamic channelId;
@dynamic userId;
@dynamic createAt;
@dynamic updateAt;
@dynamic isFolded;
@dynamic isActive;
@dynamic likes;
@dynamic views;
@dynamic punchTimes;
@dynamic hasUser, user;
@dynamic hasChannel, channel;
@dynamic hasContent, content;
@dynamic replyCount;
@dynamic repliesArray, repliesArray_Count;
@dynamic isLiked;
@dynamic myChoice;

typedef struct ZTMSense__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  uint32_t createAt;
  uint32_t updateAt;
  int32_t isFolded;
  int32_t isActive;
  int32_t likes;
  int32_t views;
  int32_t punchTimes;
  int32_t replyCount;
  int32_t isLiked;
  int32_t myChoice;
  NSString *id_p;
  NSString *channelId;
  NSString *userId;
  ZTMUserDescription *user;
  ZTMChannel *channel;
  ZTMContent *content;
  NSMutableArray *repliesArray;
} ZTMSense__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_ChannelId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, channelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_CreateAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "updateAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_UpdateAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, updateAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "isFolded",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_IsFolded,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, isFolded),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_IsActive,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "likes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_Likes,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, likes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "views",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_Views,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, views),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "punchTimes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_PunchTimes,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, punchTimes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMSense_FieldNumber_User,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannel),
        .number = ZTMSense_FieldNumber_Channel,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMContent),
        .number = ZTMSense_FieldNumber_Content,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replyCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_ReplyCount,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, replyCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "repliesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMReply),
        .number = ZTMSense_FieldNumber_RepliesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, repliesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isLiked",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_IsLiked,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, isLiked),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "myChoice",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSense_FieldNumber_MyChoice,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ZTMSense__storage_, myChoice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSense class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSense__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\003\t\000\004\006\000\005\010\000\006\010\000\007\010\000\010\010\000\013\n\000h\n\000j\007\000k\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSenseConfig

@implementation ZTMSenseConfig

@dynamic hasFoot, foot;
@dynamic actionsArray, actionsArray_Count;
@dynamic hasPush, push;

typedef struct ZTMSenseConfig__storage_ {
  uint32_t _has_storage_[1];
  ZTMSenseFoot *foot;
  NSMutableArray *actionsArray;
  ZTMSensePush *push;
} ZTMSenseConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "foot",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSenseFoot),
        .number = ZTMSenseConfig_FieldNumber_Foot,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSenseConfig__storage_, foot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSenseAction),
        .number = ZTMSenseConfig_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMSenseConfig__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "push",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSensePush),
        .number = ZTMSenseConfig_FieldNumber_Push,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSenseConfig__storage_, push),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSenseConfig class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSenseConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMContent

@implementation ZTMContent

@dynamic contentId;
@dynamic txt;
@dynamic hasPhoto, photo;
@dynamic hasMovie, movie;
@dynamic hasMusic, music;
@dynamic hasVideo, video;
@dynamic hasSound, sound;
@dynamic hasChannel, channel;
@dynamic hasProduct, product;
@dynamic mediaType;

typedef struct ZTMContent__storage_ {
  uint32_t _has_storage_[1];
  uint32_t mediaType;
  NSString *contentId;
  NSString *txt;
  ZTMPhotoDescription *photo;
  ZTMMovieDescription *movie;
  ZTMMusicDescription *music;
  ZTMVideoDescription *video;
  ZTMSoundDescription *sound;
  ZTMChannelInSense *channel;
  ZTMProductDescription *product;
} ZTMContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContent_FieldNumber_ContentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, contentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContent_FieldNumber_Txt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, txt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "photo",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMPhotoDescription),
        .number = ZTMContent_FieldNumber_Photo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, photo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "movie",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMMovieDescription),
        .number = ZTMContent_FieldNumber_Movie,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, movie),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "music",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMMusicDescription),
        .number = ZTMContent_FieldNumber_Music,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, music),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMVideoDescription),
        .number = ZTMContent_FieldNumber_Video,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sound",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSoundDescription),
        .number = ZTMContent_FieldNumber_Sound,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, sound),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelInSense),
        .number = ZTMContent_FieldNumber_Channel,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "product",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMProductDescription),
        .number = ZTMContent_FieldNumber_Product,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, product),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mediaType",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContent_FieldNumber_MediaType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMContent__storage_, mediaType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMContent class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\024\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMPunch

@implementation ZTMPunch

@dynamic punchesArray, punchesArray_Count;
@dynamic totalPunches;
@dynamic totalJoiners;
@dynamic punchDesc;
@dynamic punchStatusArray, punchStatusArray_Count;
@dynamic punchTimes;
@dynamic isPunched;

typedef struct ZTMPunch__storage_ {
  uint32_t _has_storage_[1];
  int32_t totalPunches;
  int32_t totalJoiners;
  int32_t punchTimes;
  int32_t isPunched;
  NSMutableArray *punchesArray;
  NSString *punchDesc;
  GPBInt32Array *punchStatusArray;
} ZTMPunch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "punchesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMPunchRecord),
        .number = ZTMPunch_FieldNumber_PunchesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMPunch__storage_, punchesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalPunches",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunch_FieldNumber_TotalPunches,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMPunch__storage_, totalPunches),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalJoiners",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunch_FieldNumber_TotalJoiners,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMPunch__storage_, totalJoiners),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "punchDesc",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunch_FieldNumber_PunchDesc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMPunch__storage_, punchDesc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "punchStatusArray",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunch_FieldNumber_PunchStatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMPunch__storage_, punchStatusArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "punchTimes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunch_FieldNumber_PunchTimes,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMPunch__storage_, punchTimes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isPunched",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunch_FieldNumber_IsPunched,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMPunch__storage_, isPunched),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMPunch class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMPunch__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\014\000\003\014\000\004\t\000\005\000punchStatus\000\006\n\000\007\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMVoteConfig

@implementation ZTMVoteConfig

@dynamic total;
@dynamic choicesArray, choicesArray_Count;

typedef struct ZTMVoteConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  NSMutableArray *choicesArray;
} ZTMVoteConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVoteConfig_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMVoteConfig__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "choicesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMVoteChoice),
        .number = ZTMVoteConfig_FieldNumber_ChoicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMVoteConfig__storage_, choicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMVoteConfig class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMVoteConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMAppConfiguration

@implementation ZTMAppConfiguration

@dynamic hasURLDomain, URLDomain;
@dynamic hasIos, ios;
@dynamic hasAndroid, android;
@dynamic splashesArray, splashesArray_Count;
@dynamic hasCenterTab, centerTab;
@dynamic userAgreement;
@dynamic ownerNotice;
@dynamic faq;
@dynamic channelsCreatedId;
@dynamic channelsCreatedName;
@dynamic channelsCreatedIcon;
@dynamic channelsAttitudedId;
@dynamic channelsAttitudedName;
@dynamic channelsAttitudedIcon;
@dynamic leanCloudAppId;
@dynamic leanCloudAppKey;
@dynamic aliPushAppId;
@dynamic aliPushAppKey;
@dynamic xmPushAppKey;
@dynamic xmPushAppId;
@dynamic hwPushAppKey;
@dynamic hwPushAppId;
@dynamic serviceDialects, serviceDialects_Count;

typedef struct ZTMAppConfiguration__storage_ {
  uint32_t _has_storage_[1];
  ZTMConfigurationUrlDomain *URLDomain;
  ZTMConfigurationVersion *ios;
  ZTMConfigurationVersion *android;
  NSMutableArray *splashesArray;
  ZTMConfigurationTab *centerTab;
  NSString *userAgreement;
  NSString *ownerNotice;
  NSString *faq;
  NSString *channelsCreatedId;
  NSString *channelsCreatedName;
  NSString *channelsCreatedIcon;
  NSString *channelsAttitudedId;
  NSString *channelsAttitudedName;
  NSString *channelsAttitudedIcon;
  NSString *leanCloudAppId;
  NSString *leanCloudAppKey;
  NSString *aliPushAppId;
  NSString *aliPushAppKey;
  NSString *xmPushAppKey;
  NSString *xmPushAppId;
  NSString *hwPushAppKey;
  NSString *hwPushAppId;
  GPBInt32ObjectDictionary *serviceDialects;
} ZTMAppConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URLDomain",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMConfigurationUrlDomain),
        .number = ZTMAppConfiguration_FieldNumber_URLDomain,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, URLDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ios",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMConfigurationVersion),
        .number = ZTMAppConfiguration_FieldNumber_Ios,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, ios),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "android",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMConfigurationVersion),
        .number = ZTMAppConfiguration_FieldNumber_Android,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, android),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "splashesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMConfigurationSplash),
        .number = ZTMAppConfiguration_FieldNumber_SplashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, splashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "centerTab",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMConfigurationTab),
        .number = ZTMAppConfiguration_FieldNumber_CenterTab,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, centerTab),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userAgreement",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_UserAgreement,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, userAgreement),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ownerNotice",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_OwnerNotice,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, ownerNotice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faq",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_Faq,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, faq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsCreatedId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_ChannelsCreatedId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, channelsCreatedId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsCreatedName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_ChannelsCreatedName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, channelsCreatedName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsCreatedIcon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_ChannelsCreatedIcon,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, channelsCreatedIcon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsAttitudedId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_ChannelsAttitudedId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, channelsAttitudedId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsAttitudedName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_ChannelsAttitudedName,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, channelsAttitudedName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsAttitudedIcon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_ChannelsAttitudedIcon,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, channelsAttitudedIcon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "leanCloudAppId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_LeanCloudAppId,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, leanCloudAppId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "leanCloudAppKey",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_LeanCloudAppKey,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, leanCloudAppKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aliPushAppId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_AliPushAppId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, aliPushAppId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aliPushAppKey",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_AliPushAppKey,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, aliPushAppKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "xmPushAppKey",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_XmPushAppKey,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, xmPushAppKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "xmPushAppId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_XmPushAppId,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, xmPushAppId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hwPushAppKey",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_HwPushAppKey,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, hwPushAppKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hwPushAppId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_HwPushAppId,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, hwPushAppId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serviceDialects",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAppConfiguration_FieldNumber_ServiceDialects,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMAppConfiguration__storage_, serviceDialects),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyInt32 | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMAppConfiguration class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMAppConfiguration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\023\001!!\'\000\005\t\000\010\r\000\t\013\000\036\021\000\037\023\000 \023\000!\023\000\"\025\000#\025\0002\016\0003\017\0004"
        "\014\0005\r\0006\014\0007\013\0008\014\0009\013\000F\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMDiscoveryBanner

@implementation ZTMDiscoveryBanner

@dynamic id_p;
@dynamic title;
@dynamic category;
@dynamic themesArray, themesArray_Count;

typedef struct ZTMDiscoveryBanner__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *title;
  NSString *category;
  NSMutableArray *themesArray;
} ZTMDiscoveryBanner__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryBanner_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMDiscoveryBanner__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryBanner_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMDiscoveryBanner__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryBanner_FieldNumber_Category,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMDiscoveryBanner__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "themesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMDiscoveryTheme),
        .number = ZTMDiscoveryBanner_FieldNumber_ThemesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMDiscoveryBanner__storage_, themesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMDiscoveryBanner class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMDiscoveryBanner__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMDiscoveryChannels

@implementation ZTMDiscoveryChannels

@dynamic title;
@dynamic channelId;
@dynamic rule;
@dynamic channelsArray, channelsArray_Count;
@dynamic next;

typedef struct ZTMDiscoveryChannels__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *channelId;
  NSString *rule;
  NSMutableArray *channelsArray;
  NSString *next;
} ZTMDiscoveryChannels__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryChannels_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMDiscoveryChannels__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryChannels_FieldNumber_ChannelId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMDiscoveryChannels__storage_, channelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rule",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryChannels_FieldNumber_Rule,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMDiscoveryChannels__storage_, rule),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannel),
        .number = ZTMDiscoveryChannels_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMDiscoveryChannels__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "next",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryChannels_FieldNumber_Next,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMDiscoveryChannels__storage_, next),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMDiscoveryChannels class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMDiscoveryChannels__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMReply

@implementation ZTMReply

@dynamic id_p;
@dynamic createAt;
@dynamic targetType;
@dynamic content;
@dynamic userId;
@dynamic replyToId;
@dynamic replyToUserId;
@dynamic targetId;
@dynamic targetUserId;
@dynamic targetParentId;
@dynamic targetParentUserId;
@dynamic contentType;
@dynamic contentLength;
@dynamic totalPraises;
@dynamic hasUser, user;
@dynamic hasReplyToUser, replyToUser;
@dynamic replySource;
@dynamic isPraised;

typedef struct ZTMReply__storage_ {
  uint32_t _has_storage_[1];
  uint32_t createAt;
  int32_t replySource;
  int32_t isPraised;
  NSString *id_p;
  NSString *targetType;
  NSString *content;
  NSString *userId;
  NSString *replyToId;
  NSString *replyToUserId;
  NSString *targetId;
  NSString *targetUserId;
  NSString *targetParentId;
  NSString *targetParentUserId;
  NSString *contentType;
  NSString *contentLength;
  NSString *totalPraises;
  ZTMUserDescription *user;
  ZTMUserDescription *replyToUser;
} ZTMReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_CreateAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "targetType",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_TargetType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, targetType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_UserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyToId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_ReplyToId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, replyToId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyToUserId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_ReplyToUserId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, replyToUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_TargetId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetUserId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_TargetUserId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, targetUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetParentId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_TargetParentId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, targetParentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetParentUserId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_TargetParentUserId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, targetParentUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentType",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_ContentType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, contentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentLength",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_ContentLength,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, contentLength),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalPraises",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_TotalPraises,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, totalPraises),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMReply_FieldNumber_User,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replyToUser",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMReply_FieldNumber_ReplyToUser,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, replyToUser),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replySource",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_ReplySource,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, replySource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isPraised",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReply_FieldNumber_IsPraised,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ZTMReply__storage_, isPraised),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMReply class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMReply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\017\002\010\000\003\n\000\005\006\000\006\t\000\007\r\000\010\010\000\t\014\000\n\016\000\013\022\000\014\013\000\r\r\000\016\014\000f\013\000"
        "g\013\000h\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMUserProfile

@implementation ZTMUserProfile

@dynamic id_p;
@dynamic userName;
@dynamic avatar;
@dynamic isActive;
@dynamic sex;
@dynamic createAt;
@dynamic cityCode;
@dynamic timeZone;
@dynamic tokenServer;
@dynamic tel;
@dynamic openId;
@dynamic isStaff;
@dynamic isAgreeOwnerNotice;
@dynamic createSenseCount;
@dynamic followChannelCount;

typedef struct ZTMUserProfile__storage_ {
  uint32_t _has_storage_[1];
  int32_t isActive;
  int32_t sex;
  uint32_t createAt;
  int32_t isStaff;
  int32_t isAgreeOwnerNotice;
  int32_t createSenseCount;
  int32_t followChannelCount;
  NSString *id_p;
  NSString *userName;
  NSString *avatar;
  NSString *cityCode;
  NSString *timeZone;
  NSString *tokenServer;
  NSString *tel;
  NSString *openId;
} ZTMUserProfile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_IsActive,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_CreateAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "cityCode",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_CityCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, cityCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_TimeZone,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokenServer",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_TokenServer,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, tokenServer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tel",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_Tel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, tel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "openId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_OpenId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, openId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isStaff",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_IsStaff,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, isStaff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAgreeOwnerNotice",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_IsAgreeOwnerNotice,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, isAgreeOwnerNotice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createSenseCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_CreateSenseCount,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, createSenseCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "followChannelCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserProfile_FieldNumber_FollowChannelCount,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMUserProfile__storage_, followChannelCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMUserProfile class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMUserProfile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\002\010\000\004\010\000\006\010\000\007\010\000\010\010\000\t\013\000\013\006\000\014\007\000\r\022\000e\020\000f\022\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMUserStatus

@implementation ZTMUserStatus

@dynamic id_p;
@dynamic userName;
@dynamic avatar;
@dynamic isActive;
@dynamic sex;
@dynamic createAt;
@dynamic cityCode;
@dynamic timeZone;
@dynamic tokenServer;
@dynamic tel;
@dynamic openId;
@dynamic isStaff;
@dynamic isAgreeOwnerNotice;
@dynamic loginAt;
@dynamic joinChannelsArray, joinChannelsArray_Count;
@dynamic createChannelsArray, createChannelsArray_Count;
@dynamic lastOperation;
@dynamic updateAt;
@dynamic isOpenFriendship;

typedef struct ZTMUserStatus__storage_ {
  uint32_t _has_storage_[1];
  int32_t isActive;
  int32_t sex;
  uint32_t createAt;
  int32_t isStaff;
  int32_t isAgreeOwnerNotice;
  uint32_t loginAt;
  uint32_t updateAt;
  int32_t isOpenFriendship;
  NSString *id_p;
  NSString *userName;
  NSString *avatar;
  NSString *cityCode;
  NSString *timeZone;
  NSString *tokenServer;
  NSString *tel;
  NSString *openId;
  NSMutableArray *joinChannelsArray;
  NSMutableArray *createChannelsArray;
  NSString *lastOperation;
} ZTMUserStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_IsActive,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_CreateAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "cityCode",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_CityCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, cityCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_TimeZone,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokenServer",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_TokenServer,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, tokenServer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tel",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_Tel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, tel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "openId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_OpenId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, openId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isStaff",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_IsStaff,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, isStaff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAgreeOwnerNotice",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_IsAgreeOwnerNotice,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, isAgreeOwnerNotice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "loginAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_LoginAt,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, loginAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "joinChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelDescription),
        .number = ZTMUserStatus_FieldNumber_JoinChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, joinChannelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelDescription),
        .number = ZTMUserStatus_FieldNumber_CreateChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, createChannelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastOperation",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_LastOperation,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, lastOperation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "updateAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_UpdateAt,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, updateAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "isOpenFriendship",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserStatus_FieldNumber_IsOpenFriendship,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ZTMUserStatus__storage_, isOpenFriendship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMUserStatus class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMUserStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\017\002\010\000\004\010\000\006\010\000\007\010\000\010\010\000\t\013\000\013\006\000\014\007\000\r\022\000e\007\000f\000joinCha"
        "nnels\000g\000createChannels\000h\r\000i\010\000j\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMEmoticon

@implementation ZTMEmoticon

@dynamic id_p;
@dynamic name;
@dynamic cover;
@dynamic author;
@dynamic isRsuv;
@dynamic stickersArray, stickersArray_Count;

typedef struct ZTMEmoticon__storage_ {
  uint32_t _has_storage_[1];
  int32_t isRsuv;
  NSString *id_p;
  NSString *name;
  NSString *cover;
  NSString *author;
  NSMutableArray *stickersArray;
} ZTMEmoticon__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMEmoticon_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMEmoticon__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ZTMEmoticon_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMEmoticon__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cover",
        .dataTypeSpecific.className = NULL,
        .number = ZTMEmoticon_FieldNumber_Cover,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMEmoticon__storage_, cover),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "author",
        .dataTypeSpecific.className = NULL,
        .number = ZTMEmoticon_FieldNumber_Author,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMEmoticon__storage_, author),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isRsuv",
        .dataTypeSpecific.className = NULL,
        .number = ZTMEmoticon_FieldNumber_IsRsuv,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMEmoticon__storage_, isRsuv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stickersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSticker),
        .number = ZTMEmoticon_FieldNumber_StickersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMEmoticon__storage_, stickersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMEmoticon class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMEmoticon__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMContacts

@implementation ZTMContacts

@dynamic id_p;
@dynamic userName;
@dynamic avatar;
@dynamic isActive;
@dynamic sex;
@dynamic createAt;
@dynamic cityCode;
@dynamic timeZone;
@dynamic tokenServer;
@dynamic tel;
@dynamic openId;
@dynamic isStaff;
@dynamic isAgreeOwnerNotice;
@dynamic cvsId;
@dynamic identity;
@dynamic bgColor;
@dynamic isTalker;
@dynamic isBroadcast;
@dynamic isTopping;
@dynamic toppingAt;
@dynamic pinyin;
@dynamic isMyContacts;
@dynamic isMyCvs;

typedef struct ZTMContacts__storage_ {
  uint32_t _has_storage_[1];
  int32_t isActive;
  int32_t sex;
  uint32_t createAt;
  int32_t isStaff;
  int32_t isAgreeOwnerNotice;
  int32_t isTalker;
  int32_t isBroadcast;
  int32_t isTopping;
  uint32_t toppingAt;
  int32_t isMyContacts;
  int32_t isMyCvs;
  NSString *id_p;
  NSString *userName;
  NSString *avatar;
  NSString *cityCode;
  NSString *timeZone;
  NSString *tokenServer;
  NSString *tel;
  NSString *openId;
  NSString *cvsId;
  NSString *identity;
  NSString *bgColor;
  NSString *pinyin;
} ZTMContacts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_IsActive,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_CreateAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "cityCode",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_CityCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, cityCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_TimeZone,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokenServer",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_TokenServer,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, tokenServer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tel",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_Tel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, tel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "openId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_OpenId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, openId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isStaff",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_IsStaff,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, isStaff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAgreeOwnerNotice",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_IsAgreeOwnerNotice,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, isAgreeOwnerNotice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cvsId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_CvsId,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, cvsId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identity",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_Identity,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, identity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgColor",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_BgColor,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, bgColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isTalker",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_IsTalker,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, isTalker),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isBroadcast",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_IsBroadcast,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, isBroadcast),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isTopping",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_IsTopping,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, isTopping),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toppingAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_ToppingAt,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, toppingAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "pinyin",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_Pinyin,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, pinyin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMyContacts",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_IsMyContacts,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, isMyContacts),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isMyCvs",
        .dataTypeSpecific.className = NULL,
        .number = ZTMContacts_FieldNumber_IsMyCvs,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(ZTMContacts__storage_, isMyCvs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMContacts class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMContacts__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\021\002\010\000\004\010\000\006\010\000\007\010\000\010\010\000\t\013\000\013\006\000\014\007\000\r\022\000e\005\000g\007\000h\010\000i\013\000"
        "j\t\000k\t\000m\014\000n\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMPushMessage

@implementation ZTMPushMessage

@dynamic hasContacts, contacts;
@dynamic title;
@dynamic content;
@dynamic createAt;
@dynamic img;
@dynamic style;
@dynamic URL;
@dynamic isDev;
@dynamic relationship;

typedef struct ZTMPushMessage__storage_ {
  uint32_t _has_storage_[1];
  uint32_t createAt;
  int32_t isDev;
  int32_t relationship;
  ZTMContacts *contacts;
  NSString *title;
  NSString *content;
  NSString *img;
  NSString *style;
  NSString *URL;
} ZTMPushMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contacts",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMContacts),
        .number = ZTMPushMessage_FieldNumber_Contacts,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMPushMessage__storage_, contacts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPushMessage_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMPushMessage__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPushMessage_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMPushMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPushMessage_FieldNumber_CreateAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMPushMessage__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPushMessage_FieldNumber_Img,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMPushMessage__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "style",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPushMessage_FieldNumber_Style,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMPushMessage__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPushMessage_FieldNumber_URL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMPushMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isDev",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPushMessage_FieldNumber_IsDev,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMPushMessage__storage_, isDev),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "relationship",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPushMessage_FieldNumber_Relationship,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMPushMessage__storage_, relationship),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMPushMessage class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMPushMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\010\000\007!!!\000\010\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMTalkMessage

@implementation ZTMTalkMessage

@dynamic txt;
@dynamic hasSpeech, speech;
@dynamic img;
@dynamic hasSticker, sticker;
@dynamic hasDomain, domain;
@dynamic hasVote, vote;
@dynamic hasRed, red;
@dynamic isPush;
@dynamic hasPushMessage, pushMessage;
@dynamic senderName;
@dynamic isBroadcast;
@dynamic createAt;

typedef struct ZTMTalkMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t isPush;
  int32_t isBroadcast;
  uint32_t createAt;
  NSString *txt;
  ZTMSpeech *speech;
  NSString *img;
  ZTMStickerCanvas *sticker;
  ZTMDomainObject *domain;
  ZTMVoteMessage *vote;
  ZTMRed *red;
  ZTMPushMessage *pushMessage;
  NSString *senderName;
} ZTMTalkMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMTalkMessage_FieldNumber_Txt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, txt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "speech",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSpeech),
        .number = ZTMTalkMessage_FieldNumber_Speech,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, speech),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = ZTMTalkMessage_FieldNumber_Img,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sticker",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMStickerCanvas),
        .number = ZTMTalkMessage_FieldNumber_Sticker,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, sticker),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMDomainObject),
        .number = ZTMTalkMessage_FieldNumber_Domain,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, domain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vote",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMVoteMessage),
        .number = ZTMTalkMessage_FieldNumber_Vote,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, vote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "red",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMRed),
        .number = ZTMTalkMessage_FieldNumber_Red,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, red),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isPush",
        .dataTypeSpecific.className = NULL,
        .number = ZTMTalkMessage_FieldNumber_IsPush,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, isPush),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pushMessage",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMPushMessage),
        .number = ZTMTalkMessage_FieldNumber_PushMessage,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, pushMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senderName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMTalkMessage_FieldNumber_SenderName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, senderName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isBroadcast",
        .dataTypeSpecific.className = NULL,
        .number = ZTMTalkMessage_FieldNumber_IsBroadcast,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, isBroadcast),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMTalkMessage_FieldNumber_CreateAt,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMTalkMessage__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMTalkMessage class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMTalkMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\010\006\000\t\013\000\n\n\000\013\013\000\014\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMDomainObject

@implementation ZTMDomainObject

@dynamic style;
@dynamic URL;
@dynamic txt;
@dynamic img;

typedef struct ZTMDomainObject__storage_ {
  uint32_t _has_storage_[1];
  NSString *style;
  NSString *URL;
  NSString *txt;
  NSString *img;
} ZTMDomainObject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDomainObject_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMDomainObject__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDomainObject_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMDomainObject__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDomainObject_FieldNumber_Txt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMDomainObject__storage_, txt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDomainObject_FieldNumber_Img,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMDomainObject__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMDomainObject class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMDomainObject__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMVoteMessage

@implementation ZTMVoteMessage

@dynamic style;
@dynamic URL;
@dynamic txt;
@dynamic img;
@dynamic hasUser, user;
@dynamic choice;

typedef struct ZTMVoteMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *style;
  NSString *URL;
  NSString *txt;
  NSString *img;
  ZTMUserDescription *user;
  NSString *choice;
} ZTMVoteMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVoteMessage_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMVoteMessage__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVoteMessage_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMVoteMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVoteMessage_FieldNumber_Txt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMVoteMessage__storage_, txt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVoteMessage_FieldNumber_Img,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMVoteMessage__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMVoteMessage_FieldNumber_User,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMVoteMessage__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "choice",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVoteMessage_FieldNumber_Choice,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMVoteMessage__storage_, choice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMVoteMessage class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMVoteMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMStickerCanvas

@implementation ZTMStickerCanvas

@dynamic attachedId;
@dynamic attachedTimestamp;
@dynamic width;
@dynamic height;
@dynamic attachesArray, attachesArray_Count;

typedef struct ZTMStickerCanvas__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *attachedId;
  NSMutableArray *attachesArray;
  uint64_t attachedTimestamp;
} ZTMStickerCanvas__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attachedId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerCanvas_FieldNumber_AttachedId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMStickerCanvas__storage_, attachedId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attachedTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerCanvas_FieldNumber_AttachedTimestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMStickerCanvas__storage_, attachedTimestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerCanvas_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMStickerCanvas__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerCanvas_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMStickerCanvas__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "attachesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMStickerAttach),
        .number = ZTMStickerCanvas_FieldNumber_AttachesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMStickerCanvas__storage_, attachesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMStickerCanvas class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMStickerCanvas__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMStickerAttach

@implementation ZTMStickerAttach

@dynamic URL;
@dynamic top;
@dynamic left;
@dynamic width;
@dynamic height;
@dynamic roll;

typedef struct ZTMStickerAttach__storage_ {
  uint32_t _has_storage_[1];
  int32_t top;
  int32_t left;
  int32_t width;
  int32_t height;
  float roll;
  NSString *URL;
} ZTMStickerAttach__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerAttach_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMStickerAttach__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "top",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerAttach_FieldNumber_Top,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMStickerAttach__storage_, top),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "left",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerAttach_FieldNumber_Left,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMStickerAttach__storage_, left),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerAttach_FieldNumber_Width,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMStickerAttach__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerAttach_FieldNumber_Height,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMStickerAttach__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roll",
        .dataTypeSpecific.className = NULL,
        .number = ZTMStickerAttach_FieldNumber_Roll,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMStickerAttach__storage_, roll),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMStickerAttach class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMStickerAttach__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMRed

@implementation ZTMRed

@dynamic txt;
@dynamic cent;

typedef struct ZTMRed__storage_ {
  uint32_t _has_storage_[1];
  int32_t cent;
  NSString *txt;
} ZTMRed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMRed_FieldNumber_Txt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMRed__storage_, txt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cent",
        .dataTypeSpecific.className = NULL,
        .number = ZTMRed_FieldNumber_Cent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMRed__storage_, cent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMRed class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMRed__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSpeech

@implementation ZTMSpeech

@dynamic duration;
@dynamic URL;

typedef struct ZTMSpeech__storage_ {
  uint32_t _has_storage_[1];
  float duration;
  NSString *URL;
} ZTMSpeech__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSpeech_FieldNumber_Duration,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSpeech__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSpeech_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSpeech__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSpeech class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSpeech__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMHandPaintingWrapped

@implementation ZTMHandPaintingWrapped

@dynamic zipped;
@dynamic hasHp, hp;
@dynamic zip;

typedef struct ZTMHandPaintingWrapped__storage_ {
  uint32_t _has_storage_[1];
  ZTMHandPainting *hp;
  NSData *zip;
} ZTMHandPaintingWrapped__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "zipped",
        .dataTypeSpecific.className = NULL,
        .number = ZTMHandPaintingWrapped_FieldNumber_Zipped,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hp",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMHandPainting),
        .number = ZTMHandPaintingWrapped_FieldNumber_Hp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMHandPaintingWrapped__storage_, hp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "zip",
        .dataTypeSpecific.className = NULL,
        .number = ZTMHandPaintingWrapped_FieldNumber_Zip,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMHandPaintingWrapped__storage_, zip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMHandPaintingWrapped class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMHandPaintingWrapped__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMHandPainting

@implementation ZTMHandPainting

@dynamic strokeColor;
@dynamic backgroundColor;
@dynamic hasBackgroundMask, backgroundMask;
@dynamic strokesArray, strokesArray_Count;

typedef struct ZTMHandPainting__storage_ {
  uint32_t _has_storage_[1];
  uint32_t strokeColor;
  uint32_t backgroundColor;
  ZTMHandPainting *backgroundMask;
  NSMutableArray *strokesArray;
} ZTMHandPainting__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "strokeColor",
        .dataTypeSpecific.className = NULL,
        .number = ZTMHandPainting_FieldNumber_StrokeColor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMHandPainting__storage_, strokeColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "backgroundColor",
        .dataTypeSpecific.className = NULL,
        .number = ZTMHandPainting_FieldNumber_BackgroundColor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMHandPainting__storage_, backgroundColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "backgroundMask",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMHandPainting),
        .number = ZTMHandPainting_FieldNumber_BackgroundMask,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMHandPainting__storage_, backgroundMask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "strokesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMStroke),
        .number = ZTMHandPainting_FieldNumber_StrokesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMHandPainting__storage_, strokesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMHandPainting class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMHandPainting__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\017\000\003\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMStroke

@implementation ZTMStroke

@dynamic style;
@dynamic pointsArray, pointsArray_Count;

typedef struct ZTMStroke__storage_ {
  uint32_t _has_storage_[1];
  ZTMStroke_Style style;
  NSMutableArray *pointsArray;
} ZTMStroke__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = ZTMStroke_Style_EnumDescriptor,
        .number = ZTMStroke_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMStroke__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pointsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMPoint),
        .number = ZTMStroke_FieldNumber_PointsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMStroke__storage_, pointsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMStroke class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMStroke__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ZTMStroke_Style_RawValue(ZTMStroke *message) {
  GPBDescriptor *descriptor = [ZTMStroke descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ZTMStroke_FieldNumber_Style];
  return GPBGetMessageInt32Field(message, field);
}

void SetZTMStroke_Style_RawValue(ZTMStroke *message, int32_t value) {
  GPBDescriptor *descriptor = [ZTMStroke descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ZTMStroke_FieldNumber_Style];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ZTMStroke_Style

GPBEnumDescriptor *ZTMStroke_Style_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Pen1\000Pen2\000Pen3\000Erasing\000";
    static const int32_t values[] = {
        ZTMStroke_Style_Pen1,
        ZTMStroke_Style_Pen2,
        ZTMStroke_Style_Pen3,
        ZTMStroke_Style_Erasing,
    };
    static const char *extraTextFormatInfo = "\003\000c\201\000\001c\201\000\002c\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZTMStroke_Style)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZTMStroke_Style_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZTMStroke_Style_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZTMStroke_Style_Pen1:
    case ZTMStroke_Style_Pen2:
    case ZTMStroke_Style_Pen3:
    case ZTMStroke_Style_Erasing:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZTMPoint

@implementation ZTMPoint

@dynamic x;
@dynamic y;

typedef struct ZTMPoint__storage_ {
  uint32_t _has_storage_[1];
  int32_t x;
  int32_t y;
} ZTMPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPoint_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMPoint__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPoint_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMPoint__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMPoint class]
                                     rootClass:[ZTMCompositeRoot class]
                                          file:ZTMCompositeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
