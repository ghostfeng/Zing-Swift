// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: response.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Response.pbobjc.h"
 #import "Plain.pbobjc.h"
 #import "Composite.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ZTMResponseRoot

@implementation ZTMResponseRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ZTMResponseRoot_FileDescriptor

static GPBFileDescriptor *ZTMResponseRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"zing.model.response"
                                                 objcPrefix:@"ZTM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ZTMZingResponse

@implementation ZTMZingResponse

@dynamic code;
@dynamic next;
@dynamic duration;
@dynamic error;
@dynamic requestAt;
@dynamic hasConfig, config;
@dynamic hasOssToken, ossToken;
@dynamic hasUserConfig, userConfig;
@dynamic hasUser, user;
@dynamic usersArray, usersArray_Count;
@dynamic hasUserProfile, userProfile;
@dynamic hasBlacklist, blacklist;
@dynamic hasChannel, channel;
@dynamic channelsArray, channelsArray_Count;
@dynamic hasChannelProfile, channelProfile;
@dynamic stayCount;
@dynamic hasSense, sense;
@dynamic sensesArray, sensesArray_Count;
@dynamic hasTogether, together;
@dynamic voteDetailsArray, voteDetailsArray_Count;
@dynamic samplesArray, samplesArray_Count;
@dynamic banners, banners_Count;
@dynamic dscvChannelsArray, dscvChannelsArray_Count;
@dynamic repliesArray, repliesArray_Count;
@dynamic userStatusArray, userStatusArray_Count;
@dynamic channelListArray, channelListArray_Count;
@dynamic regionsArray, regionsArray_Count;
@dynamic hasContacts, contacts;
@dynamic contactsesArray, contactsesArray_Count;
@dynamic hasEmoticon, emoticon;
@dynamic emoticonsArray, emoticonsArray_Count;
@dynamic talkMessagesArray, talkMessagesArray_Count;
@dynamic pushMessagesArray, pushMessagesArray_Count;
@dynamic unreadPushCount;
@dynamic hasReply, reply;
@dynamic hasPayApplication, payApplication;
@dynamic toppingChannelsArray, toppingChannelsArray_Count;
@dynamic followedChannelsArray, followedChannelsArray_Count;
@dynamic recentPushMessagesArray, recentPushMessagesArray_Count;
@dynamic toppingContactsesArray, toppingContactsesArray_Count;
@dynamic hasSharingMessage, sharingMessage;
@dynamic followedToday;
@dynamic showModules, showModules_Count;
@dynamic unreadMessageCount;
@dynamic lastMessageAt;
@dynamic lastMessageTxt;
@dynamic hasDscvLastChannel, dscvLastChannel;
@dynamic ordinaryChannelRulesArray, ordinaryChannelRulesArray_Count;
@dynamic habitChannelRulesArray, habitChannelRulesArray_Count;
@dynamic attitudeChannelRulesArray, attitudeChannelRulesArray_Count;

typedef struct ZTMZingResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  int32_t stayCount;
  int32_t unreadPushCount;
  int32_t followedToday;
  int32_t unreadMessageCount;
  uint32_t lastMessageAt;
  NSString *next;
  NSString *duration;
  NSString *error;
  ZTMAppConfiguration *config;
  ZTMOssToken *ossToken;
  ZTMUserConfig *userConfig;
  ZTMUserDescription *user;
  NSMutableArray *usersArray;
  ZTMUserProfile *userProfile;
  ZTMBlacklist *blacklist;
  ZTMChannel *channel;
  NSMutableArray *channelsArray;
  ZTMChannelProfile *channelProfile;
  ZTMSense *sense;
  NSMutableArray *sensesArray;
  ZTMTogether *together;
  NSMutableArray *voteDetailsArray;
  GPBInt32Array *samplesArray;
  NSMutableDictionary *banners;
  NSMutableArray *dscvChannelsArray;
  NSMutableArray *repliesArray;
  NSMutableArray *userStatusArray;
  NSMutableArray *channelListArray;
  NSMutableArray *regionsArray;
  ZTMContacts *contacts;
  NSMutableArray *contactsesArray;
  ZTMEmoticon *emoticon;
  NSMutableArray *emoticonsArray;
  NSMutableArray *talkMessagesArray;
  NSMutableArray *pushMessagesArray;
  ZTMReply *reply;
  ZTMPayApplication *payApplication;
  NSMutableArray *toppingChannelsArray;
  NSMutableArray *followedChannelsArray;
  NSMutableArray *recentPushMessagesArray;
  NSMutableArray *toppingContactsesArray;
  ZTMSharingMessage *sharingMessage;
  GPBStringInt32Dictionary *showModules;
  NSString *lastMessageTxt;
  ZTMDiscoveryChannels *dscvLastChannel;
  NSMutableArray *ordinaryChannelRulesArray;
  NSMutableArray *habitChannelRulesArray;
  NSMutableArray *attitudeChannelRulesArray;
  uint64_t requestAt;
} ZTMZingResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "next",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_Next,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, next),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_Duration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_Error,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_RequestAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, requestAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "config",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMAppConfiguration),
        .number = ZTMZingResponse_FieldNumber_Config,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ossToken",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMOssToken),
        .number = ZTMZingResponse_FieldNumber_OssToken,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, ossToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserConfig),
        .number = ZTMZingResponse_FieldNumber_UserConfig,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, userConfig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMZingResponse_FieldNumber_User,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMZingResponse_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userProfile",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserProfile),
        .number = ZTMZingResponse_FieldNumber_UserProfile,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, userProfile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blacklist",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMBlacklist),
        .number = ZTMZingResponse_FieldNumber_Blacklist,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, blacklist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannel),
        .number = ZTMZingResponse_FieldNumber_Channel,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannel),
        .number = ZTMZingResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelProfile",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelProfile),
        .number = ZTMZingResponse_FieldNumber_ChannelProfile,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, channelProfile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stayCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_StayCount,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, stayCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sense",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSense),
        .number = ZTMZingResponse_FieldNumber_Sense,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, sense),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sensesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSense),
        .number = ZTMZingResponse_FieldNumber_SensesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, sensesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "together",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMTogether),
        .number = ZTMZingResponse_FieldNumber_Together,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, together),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voteDetailsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMVoteDetail),
        .number = ZTMZingResponse_FieldNumber_VoteDetailsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, voteDetailsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "samplesArray",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_SamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, samplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "banners",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMDiscoveryBanner),
        .number = ZTMZingResponse_FieldNumber_Banners,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, banners),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dscvChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMDiscoveryChannels),
        .number = ZTMZingResponse_FieldNumber_DscvChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, dscvChannelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "repliesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMReply),
        .number = ZTMZingResponse_FieldNumber_RepliesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, repliesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userStatusArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserStatus),
        .number = ZTMZingResponse_FieldNumber_UserStatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, userStatusArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelDescription),
        .number = ZTMZingResponse_FieldNumber_ChannelListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, channelListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "regionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMRegionDescription),
        .number = ZTMZingResponse_FieldNumber_RegionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, regionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contacts",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMContacts),
        .number = ZTMZingResponse_FieldNumber_Contacts,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, contacts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contactsesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMContacts),
        .number = ZTMZingResponse_FieldNumber_ContactsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, contactsesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emoticon",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMEmoticon),
        .number = ZTMZingResponse_FieldNumber_Emoticon,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, emoticon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emoticonsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMEmoticon),
        .number = ZTMZingResponse_FieldNumber_EmoticonsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, emoticonsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "talkMessagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMTalkMessage),
        .number = ZTMZingResponse_FieldNumber_TalkMessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, talkMessagesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pushMessagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMPushMessage),
        .number = ZTMZingResponse_FieldNumber_PushMessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, pushMessagesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadPushCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_UnreadPushCount,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, unreadPushCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reply",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMReply),
        .number = ZTMZingResponse_FieldNumber_Reply,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payApplication",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMPayApplication),
        .number = ZTMZingResponse_FieldNumber_PayApplication,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, payApplication),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toppingChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannel),
        .number = ZTMZingResponse_FieldNumber_ToppingChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, toppingChannelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "followedChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannel),
        .number = ZTMZingResponse_FieldNumber_FollowedChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, followedChannelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recentPushMessagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMPushMessage),
        .number = ZTMZingResponse_FieldNumber_RecentPushMessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, recentPushMessagesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toppingContactsesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMContacts),
        .number = ZTMZingResponse_FieldNumber_ToppingContactsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, toppingContactsesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sharingMessage",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSharingMessage),
        .number = ZTMZingResponse_FieldNumber_SharingMessage,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, sharingMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "followedToday",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_FollowedToday,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, followedToday),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showModules",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_ShowModules,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, showModules),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unreadMessageCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_UnreadMessageCount,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, unreadMessageCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastMessageAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_LastMessageAt,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, lastMessageAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "lastMessageTxt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMZingResponse_FieldNumber_LastMessageTxt,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, lastMessageTxt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dscvLastChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMDiscoveryChannels),
        .number = ZTMZingResponse_FieldNumber_DscvLastChannel,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, dscvLastChannel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ordinaryChannelRulesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelCreateRule),
        .number = ZTMZingResponse_FieldNumber_OrdinaryChannelRulesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, ordinaryChannelRulesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "habitChannelRulesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelCreateRule),
        .number = ZTMZingResponse_FieldNumber_HabitChannelRulesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, habitChannelRulesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attitudeChannelRulesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelCreateRule),
        .number = ZTMZingResponse_FieldNumber_AttitudeChannelRulesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMZingResponse__storage_, attitudeChannelRulesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMZingResponse class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMZingResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\034\005\t\000f\010\000g\n\000j\013\000n\016\000o\t\000t\000voteDetails\000w\000dscvC"
        "hannels\000y\000userStatus\000z\000channelList\000\202\001\000ta"
        "lkMessages\000\203\001\000pushMessages\000\204\001\017\000\206\001\016\000\207\001\000to"
        "ppingChannels\000\210\001\000followedChannels\000\211\001\000rec"
        "entPushMessages\000\212\001\000toppingContactses\000\213\001\016"
        "\000\214\001\r\000\215\001\013\000\216\001\022\000\217\001\r\000\220\001\016\000\221\001\017\000\222\001\000ordinaryChan"
        "nelRules\000\223\001\000habitChannelRules\000\224\001\000attitud"
        "eChannelRules\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMOssToken

@implementation ZTMOssToken

@dynamic accessKeyId;
@dynamic accessKeySecret;
@dynamic securityToken;
@dynamic expiration;

typedef struct ZTMOssToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *accessKeyId;
  NSString *accessKeySecret;
  NSString *securityToken;
  NSString *expiration;
} ZTMOssToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accessKeyId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMOssToken_FieldNumber_AccessKeyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMOssToken__storage_, accessKeyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accessKeySecret",
        .dataTypeSpecific.className = NULL,
        .number = ZTMOssToken_FieldNumber_AccessKeySecret,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMOssToken__storage_, accessKeySecret),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "securityToken",
        .dataTypeSpecific.className = NULL,
        .number = ZTMOssToken_FieldNumber_SecurityToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMOssToken__storage_, securityToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.className = NULL,
        .number = ZTMOssToken_FieldNumber_Expiration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMOssToken__storage_, expiration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMOssToken class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMOssToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\017\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMUserConfig

@implementation ZTMUserConfig

@dynamic isOpenFriendship;

typedef struct ZTMUserConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t isOpenFriendship;
} ZTMUserConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isOpenFriendship",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserConfig_FieldNumber_IsOpenFriendship,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMUserConfig__storage_, isOpenFriendship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMUserConfig class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMUserConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMBlacklist

@implementation ZTMBlacklist

@dynamic hateUserIdsArray, hateUserIdsArray_Count;
@dynamic beHatedUserIdsArray, beHatedUserIdsArray_Count;
@dynamic isMute;
@dynamic muteEndAt;
@dynamic hateUsersArray, hateUsersArray_Count;

typedef struct ZTMBlacklist__storage_ {
  uint32_t _has_storage_[1];
  int32_t isMute;
  uint32_t muteEndAt;
  NSMutableArray *hateUserIdsArray;
  NSMutableArray *beHatedUserIdsArray;
  NSMutableArray *hateUsersArray;
} ZTMBlacklist__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hateUserIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = ZTMBlacklist_FieldNumber_HateUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMBlacklist__storage_, hateUserIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "beHatedUserIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = ZTMBlacklist_FieldNumber_BeHatedUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMBlacklist__storage_, beHatedUserIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.className = NULL,
        .number = ZTMBlacklist_FieldNumber_IsMute,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMBlacklist__storage_, isMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "muteEndAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMBlacklist_FieldNumber_MuteEndAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMBlacklist__storage_, muteEndAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "hateUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMBlacklist_FieldNumber_HateUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMBlacklist__storage_, hateUsersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMBlacklist class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMBlacklist__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\000hateUserIds\000\002\000beHatedUserIds\000\003\006\000\004\t\000\005\000"
        "hateUsers\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelProfile

@implementation ZTMChannelProfile

@dynamic isReceiveEvent;
@dynamic isOpenFriendship;
@dynamic sexInFriendship;

typedef struct ZTMChannelProfile__storage_ {
  uint32_t _has_storage_[1];
  int32_t isReceiveEvent;
  int32_t isOpenFriendship;
  int32_t sexInFriendship;
} ZTMChannelProfile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isReceiveEvent",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelProfile_FieldNumber_IsReceiveEvent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelProfile__storage_, isReceiveEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isOpenFriendship",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelProfile_FieldNumber_IsOpenFriendship,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelProfile__storage_, isOpenFriendship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sexInFriendship",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelProfile_FieldNumber_SexInFriendship,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelProfile__storage_, sexInFriendship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelProfile class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelProfile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\016\000\002\020\000\003\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMTogether

@implementation ZTMTogether

@dynamic likes;
@dynamic likeUsersArray, likeUsersArray_Count;
@dynamic views;
@dynamic viewUsersArray, viewUsersArray_Count;

typedef struct ZTMTogether__storage_ {
  uint32_t _has_storage_[1];
  int32_t likes;
  int32_t views;
  NSMutableArray *likeUsersArray;
  NSMutableArray *viewUsersArray;
} ZTMTogether__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "likes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMTogether_FieldNumber_Likes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMTogether__storage_, likes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "likeUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMTogether_FieldNumber_LikeUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMTogether__storage_, likeUsersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "views",
        .dataTypeSpecific.className = NULL,
        .number = ZTMTogether_FieldNumber_Views,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMTogether__storage_, views),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "viewUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMTogether_FieldNumber_ViewUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMTogether__storage_, viewUsersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMTogether class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMTogether__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\000likeUsers\000\004\000viewUsers\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMVoteDetail

@implementation ZTMVoteDetail

@dynamic hasChoice, choice;
@dynamic usersArray, usersArray_Count;

typedef struct ZTMVoteDetail__storage_ {
  uint32_t _has_storage_[1];
  ZTMVoteChoice *choice;
  NSMutableArray *usersArray;
} ZTMVoteDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "choice",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMVoteChoice),
        .number = ZTMVoteDetail_FieldNumber_Choice,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMVoteDetail__storage_, choice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMVoteDetail_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMVoteDetail__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMVoteDetail class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMVoteDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelCreateRule

@implementation ZTMChannelCreateRule

@dynamic rule;
@dynamic isPassed;

typedef struct ZTMChannelCreateRule__storage_ {
  uint32_t _has_storage_[1];
  int32_t isPassed;
  NSString *rule;
} ZTMChannelCreateRule__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rule",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelCreateRule_FieldNumber_Rule,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelCreateRule__storage_, rule),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isPassed",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelCreateRule_FieldNumber_IsPassed,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelCreateRule__storage_, isPassed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelCreateRule class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelCreateRule__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelOption

@implementation ZTMChannelOption

@dynamic id_p;
@dynamic category;
@dynamic icon;
@dynamic description_p;
@dynamic refsArray, refsArray_Count;
@dynamic isReceiveEvent;
@dynamic isOpenFriendship;
@dynamic sexInFriendship;

typedef struct ZTMChannelOption__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  int32_t isReceiveEvent;
  int32_t isOpenFriendship;
  int32_t sexInFriendship;
  NSString *id_p;
  NSString *icon;
  NSString *description_p;
  NSMutableArray *refsArray;
} ZTMChannelOption__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelOption_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelOption__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelOption_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelOption__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelOption_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelOption__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelOption_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMChannelOption__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelDescription),
        .number = ZTMChannelOption_FieldNumber_RefsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMChannelOption__storage_, refsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isReceiveEvent",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelOption_FieldNumber_IsReceiveEvent,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMChannelOption__storage_, isReceiveEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isOpenFriendship",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelOption_FieldNumber_IsOpenFriendship,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMChannelOption__storage_, isOpenFriendship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sexInFriendship",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelOption_FieldNumber_SexInFriendship,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMChannelOption__storage_, sexInFriendship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelOption class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelOption__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\007\016\000\010\020\000\t\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMPayApplication

@implementation ZTMPayApplication

@dynamic payId;
@dynamic aliURL;
@dynamic wxMap, wxMap_Count;

typedef struct ZTMPayApplication__storage_ {
  uint32_t _has_storage_[1];
  NSString *payId;
  NSString *aliURL;
  NSMutableDictionary *wxMap;
} ZTMPayApplication__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPayApplication_FieldNumber_PayId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMPayApplication__storage_, payId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aliURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPayApplication_FieldNumber_AliURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMPayApplication__storage_, aliURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wxMap",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPayApplication_FieldNumber_WxMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMPayApplication__storage_, wxMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMPayApplication class]
                                     rootClass:[ZTMResponseRoot class]
                                          file:ZTMResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMPayApplication__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\005\000\002\004!!\000\003\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
