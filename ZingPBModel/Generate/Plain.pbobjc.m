// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plain.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Plain.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ZTMPlainRoot

@implementation ZTMPlainRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ZTMPlainRoot_FileDescriptor

static GPBFileDescriptor *ZTMPlainRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"zing.model.plain"
                                                 objcPrefix:@"ZTM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ZTMChannelUserIdentity

@implementation ZTMChannelUserIdentity

@dynamic id_p;
@dynamic title;
@dynamic bgColor;
@dynamic userName;

typedef struct ZTMChannelUserIdentity__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *title;
  NSString *bgColor;
  NSString *userName;
} ZTMChannelUserIdentity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelUserIdentity_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelUserIdentity__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelUserIdentity_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelUserIdentity__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgColor",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelUserIdentity_FieldNumber_BgColor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelUserIdentity__storage_, bgColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelUserIdentity_FieldNumber_UserName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMChannelUserIdentity__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelUserIdentity class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelUserIdentity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\007\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelViewHead

@implementation ZTMChannelViewHead

@dynamic imageSrc;
@dynamic URL;
@dynamic style;

typedef struct ZTMChannelViewHead__storage_ {
  uint32_t _has_storage_[1];
  NSString *imageSrc;
  NSString *URL;
  NSString *style;
} ZTMChannelViewHead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imageSrc",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewHead_FieldNumber_ImageSrc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelViewHead__storage_, imageSrc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewHead_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelViewHead__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "style",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewHead_FieldNumber_Style,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelViewHead__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelViewHead class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelViewHead__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelViewStyle

@implementation ZTMChannelViewStyle

@dynamic name;
@dynamic bgColor;
@dynamic majorColor;
@dynamic subColor;
@dynamic deactiveColor;

typedef struct ZTMChannelViewStyle__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *bgColor;
  NSString *majorColor;
  NSString *subColor;
  NSString *deactiveColor;
} ZTMChannelViewStyle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewStyle_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelViewStyle__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgColor",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewStyle_FieldNumber_BgColor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelViewStyle__storage_, bgColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "majorColor",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewStyle_FieldNumber_MajorColor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelViewStyle__storage_, majorColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subColor",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewStyle_FieldNumber_SubColor,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMChannelViewStyle__storage_, subColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deactiveColor",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewStyle_FieldNumber_DeactiveColor,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMChannelViewStyle__storage_, deactiveColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelViewStyle class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelViewStyle__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\007\000\003\n\000\004\010\000\005\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelViewTab

@implementation ZTMChannelViewTab

@dynamic title;
@dynamic URL;
@dynamic style;
@dynamic description_p;
@dynamic emptyDescription;

typedef struct ZTMChannelViewTab__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *URL;
  NSString *style;
  NSString *description_p;
  NSString *emptyDescription;
} ZTMChannelViewTab__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewTab_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelViewTab__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewTab_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelViewTab__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "style",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewTab_FieldNumber_Style,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelViewTab__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewTab_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMChannelViewTab__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emptyDescription",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelViewTab_FieldNumber_EmptyDescription,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMChannelViewTab__storage_, emptyDescription),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelViewTab class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelViewTab__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002!!!\000\005\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMPunchConfig

@implementation ZTMPunchConfig

@dynamic limitTimes;
@dynamic window;
@dynamic emoji;
@dynamic attr;
@dynamic unit;

typedef struct ZTMPunchConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t limitTimes;
  NSString *window;
  NSString *emoji;
  NSString *attr;
  NSString *unit;
} ZTMPunchConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "limitTimes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchConfig_FieldNumber_LimitTimes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMPunchConfig__storage_, limitTimes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "window",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchConfig_FieldNumber_Window,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMPunchConfig__storage_, window),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emoji",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchConfig_FieldNumber_Emoji,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMPunchConfig__storage_, emoji),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attr",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchConfig_FieldNumber_Attr,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMPunchConfig__storage_, attr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unit",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchConfig_FieldNumber_Unit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMPunchConfig__storage_, unit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMPunchConfig class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMPunchConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSenseAction

@implementation ZTMSenseAction

@dynamic title;
@dynamic action;
@dynamic icon;
@dynamic selectedIcon;

typedef struct ZTMSenseAction__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *action;
  NSString *icon;
  NSString *selectedIcon;
} ZTMSenseAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseAction_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSenseAction__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "action",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseAction_FieldNumber_Action,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSenseAction__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseAction_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMSenseAction__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selectedIcon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseAction_FieldNumber_SelectedIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMSenseAction__storage_, selectedIcon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSenseAction class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSenseAction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSenseFoot

@implementation ZTMSenseFoot

@dynamic txt;
@dynamic icon;

typedef struct ZTMSenseFoot__storage_ {
  uint32_t _has_storage_[1];
  NSString *txt;
  NSString *icon;
} ZTMSenseFoot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseFoot_FieldNumber_Txt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSenseFoot__storage_, txt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseFoot_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSenseFoot__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSenseFoot class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSenseFoot__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSensePush

@implementation ZTMSensePush

@dynamic likeByUser;
@dynamic replyByUser;
@dynamic replyToByUser;

typedef struct ZTMSensePush__storage_ {
  uint32_t _has_storage_[1];
  NSString *likeByUser;
  NSString *replyByUser;
  NSString *replyToByUser;
} ZTMSensePush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "likeByUser",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSensePush_FieldNumber_LikeByUser,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSensePush__storage_, likeByUser),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyByUser",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSensePush_FieldNumber_ReplyByUser,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSensePush__storage_, replyByUser),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyToByUser",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSensePush_FieldNumber_ReplyToByUser,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMSensePush__storage_, replyToByUser),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSensePush class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSensePush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\n\000\002\013\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMVideoConfig

@implementation ZTMVideoConfig

@dynamic minDuration;
@dynamic maxDuration;
@dynamic isAllowGallery;
@dynamic maxLengthInRecord;
@dynamic maxLengthInGallery;

typedef struct ZTMVideoConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t minDuration;
  int32_t maxDuration;
  int32_t isAllowGallery;
  uint32_t maxLengthInRecord;
  uint32_t maxLengthInGallery;
} ZTMVideoConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minDuration",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVideoConfig_FieldNumber_MinDuration,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMVideoConfig__storage_, minDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxDuration",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVideoConfig_FieldNumber_MaxDuration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMVideoConfig__storage_, maxDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAllowGallery",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVideoConfig_FieldNumber_IsAllowGallery,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMVideoConfig__storage_, isAllowGallery),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxLengthInRecord",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVideoConfig_FieldNumber_MaxLengthInRecord,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMVideoConfig__storage_, maxLengthInRecord),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "maxLengthInGallery",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVideoConfig_FieldNumber_MaxLengthInGallery,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMVideoConfig__storage_, maxLengthInGallery),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMVideoConfig class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMVideoConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\013\000\002\013\000\003\016\000\004\021\000\005\022\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelInSense

@implementation ZTMChannelInSense

@dynamic id_p;
@dynamic category;
@dynamic userId;
@dynamic name;
@dynamic icon;
@dynamic description_p;
@dynamic isActive;
@dynamic isVerify;
@dynamic isRecommend;
@dynamic isAnonymous;
@dynamic createAt;
@dynamic updateAt;
@dynamic senseCount;
@dynamic subscribeTimes;
@dynamic updateDescAt;
@dynamic lastPostAt;

typedef struct ZTMChannelInSense__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  int32_t isActive;
  int32_t isVerify;
  int32_t isRecommend;
  int32_t isAnonymous;
  uint32_t createAt;
  uint32_t updateAt;
  int32_t senseCount;
  int32_t subscribeTimes;
  uint32_t updateDescAt;
  uint32_t lastPostAt;
  NSString *id_p;
  NSString *userId;
  NSString *name;
  NSString *icon;
  NSString *description_p;
} ZTMChannelInSense__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_Description_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_IsActive,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isVerify",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_IsVerify,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, isVerify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isRecommend",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_IsRecommend,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, isRecommend),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAnonymous",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_IsAnonymous,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, isAnonymous),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_CreateAt,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "updateAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_UpdateAt,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, updateAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "senseCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_SenseCount,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, senseCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subscribeTimes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_SubscribeTimes,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, subscribeTimes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "updateDescAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_UpdateDescAt,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, updateDescAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "lastPostAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelInSense_FieldNumber_LastPostAt,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMChannelInSense__storage_, lastPostAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelInSense class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelInSense__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\003\006\000\010\010\000\t\010\000\n\013\000\013\013\000\014\010\000\r\010\000\016\n\000\017\016\000\020\014\000\021\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMMovieDescription

@implementation ZTMMovieDescription

@dynamic title;
@dynamic img;
@dynamic mid;
@dynamic subTitle;
@dynamic year;
@dynamic director;
@dynamic actor;
@dynamic cover;
@dynamic trailer;

typedef struct ZTMMovieDescription__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *img;
  NSString *mid;
  NSString *subTitle;
  NSString *year;
  NSString *director;
  NSString *actor;
  NSString *cover;
  NSString *trailer;
} ZTMMovieDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMovieDescription_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMMovieDescription__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMovieDescription_FieldNumber_Img,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMMovieDescription__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMovieDescription_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMMovieDescription__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subTitle",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMovieDescription_FieldNumber_SubTitle,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMMovieDescription__storage_, subTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "year",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMovieDescription_FieldNumber_Year,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMMovieDescription__storage_, year),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "director",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMovieDescription_FieldNumber_Director,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMMovieDescription__storage_, director),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "actor",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMovieDescription_FieldNumber_Actor,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMMovieDescription__storage_, actor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cover",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMovieDescription_FieldNumber_Cover,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMMovieDescription__storage_, cover),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trailer",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMovieDescription_FieldNumber_Trailer,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMMovieDescription__storage_, trailer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMMovieDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMMovieDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMMusicDescription

@implementation ZTMMusicDescription

@dynamic title;
@dynamic src;
@dynamic cover;
@dynamic sid;
@dynamic source;
@dynamic sourceURL;
@dynamic name;
@dynamic author;
@dynamic albumName;
@dynamic albumArtURL;
@dynamic artistName;

typedef struct ZTMMusicDescription__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *src;
  NSString *cover;
  NSString *sid;
  NSString *source;
  NSString *sourceURL;
  NSString *name;
  NSString *author;
  NSString *albumName;
  NSString *albumArtURL;
  NSString *artistName;
} ZTMMusicDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "src",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_Src,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, src),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cover",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_Cover,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, cover),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sid",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_Sid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, sid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_Source,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_SourceURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, sourceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_Name,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "author",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_Author,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, author),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "albumName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_AlbumName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, albumName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "albumArtURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_AlbumArtURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, albumArtURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "artistName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMMusicDescription_FieldNumber_ArtistName,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMMusicDescription__storage_, artistName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMMusicDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMMusicDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\006\007!!\000\t\t\000\n\t!!\000\013\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMPhotoDescription

@implementation ZTMPhotoDescription

@dynamic photo;

typedef struct ZTMPhotoDescription__storage_ {
  uint32_t _has_storage_[1];
  NSString *photo;
} ZTMPhotoDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "photo",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPhotoDescription_FieldNumber_Photo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMPhotoDescription__storage_, photo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMPhotoDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMPhotoDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMProductDescription

@implementation ZTMProductDescription

@dynamic title;
@dynamic description_p;
@dynamic pictures;
@dynamic price;
@dynamic remainingCount;
@dynamic soldCont;
@dynamic maxBuy;
@dynamic originPrice;
@dynamic expressPrice;
@dynamic isActive;
@dynamic createAt;
@dynamic updateAt;
@dynamic startAt;

typedef struct ZTMProductDescription__storage_ {
  uint32_t _has_storage_[1];
  int32_t price;
  int32_t remainingCount;
  int32_t soldCont;
  int32_t maxBuy;
  int32_t originPrice;
  int32_t expressPrice;
  int32_t isActive;
  uint32_t createAt;
  uint32_t updateAt;
  uint32_t startAt;
  NSString *title;
  NSString *description_p;
  NSString *pictures;
} ZTMProductDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pictures",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_Pictures,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, pictures),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_Price,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remainingCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_RemainingCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, remainingCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "soldCont",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_SoldCont,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, soldCont),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxBuy",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_MaxBuy,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, maxBuy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "originPrice",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_OriginPrice,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, originPrice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "expressPrice",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_ExpressPrice,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, expressPrice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_IsActive,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_CreateAt,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "updateAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_UpdateAt,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, updateAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "startAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMProductDescription_FieldNumber_StartAt,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMProductDescription__storage_, startAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMProductDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMProductDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\005\016\000\006\010\000\007\006\000\010\013\000\t\014\000\n\010\000\013\010\000\014\010\000\r\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMPunchRecord

@implementation ZTMPunchRecord

@dynamic senseId;
@dynamic times;
@dynamic createAtPb;
@dynamic value1;
@dynamic value2;

typedef struct ZTMPunchRecord__storage_ {
  uint32_t _has_storage_[1];
  int32_t times;
  uint32_t createAtPb;
  float value1;
  float value2;
  NSString *senseId;
} ZTMPunchRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senseId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchRecord_FieldNumber_SenseId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMPunchRecord__storage_, senseId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "times",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchRecord_FieldNumber_Times,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMPunchRecord__storage_, times),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAtPb",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchRecord_FieldNumber_CreateAtPb,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMPunchRecord__storage_, createAtPb),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "value1",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchRecord_FieldNumber_Value1,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMPunchRecord__storage_, value1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "value2",
        .dataTypeSpecific.className = NULL,
        .number = ZTMPunchRecord_FieldNumber_Value2,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMPunchRecord__storage_, value2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMPunchRecord class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMPunchRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\003\010\342\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSoundDescription

@implementation ZTMSoundDescription

@dynamic src;
@dynamic samplesArray, samplesArray_Count;
@dynamic sampleCount;
@dynamic sampleRate;
@dynamic duration;
@dynamic recordAt;
@dynamic currentSampleCount;

typedef struct ZTMSoundDescription__storage_ {
  uint32_t _has_storage_[1];
  int32_t sampleCount;
  int32_t duration;
  uint32_t recordAt;
  int32_t currentSampleCount;
  NSString *src;
  GPBInt32Array *samplesArray;
  NSString *sampleRate;
} ZTMSoundDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "src",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSoundDescription_FieldNumber_Src,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSoundDescription__storage_, src),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "samplesArray",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSoundDescription_FieldNumber_SamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMSoundDescription__storage_, samplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sampleCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSoundDescription_FieldNumber_SampleCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSoundDescription__storage_, sampleCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sampleRate",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSoundDescription_FieldNumber_SampleRate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMSoundDescription__storage_, sampleRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSoundDescription_FieldNumber_Duration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMSoundDescription__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "recordAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSoundDescription_FieldNumber_RecordAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMSoundDescription__storage_, recordAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "currentSampleCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSoundDescription_FieldNumber_CurrentSampleCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMSoundDescription__storage_, currentSampleCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSoundDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSoundDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\003\013\000\004\n\000\006\010\000\007\022\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMVideoDescription

@implementation ZTMVideoDescription

@dynamic src;
@dynamic cover;
@dynamic sticker;
@dynamic duration;

typedef struct ZTMVideoDescription__storage_ {
  uint32_t _has_storage_[1];
  int32_t duration;
  NSString *src;
  NSString *cover;
  NSString *sticker;
} ZTMVideoDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "src",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVideoDescription_FieldNumber_Src,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMVideoDescription__storage_, src),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cover",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVideoDescription_FieldNumber_Cover,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMVideoDescription__storage_, cover),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sticker",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVideoDescription_FieldNumber_Sticker,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMVideoDescription__storage_, sticker),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVideoDescription_FieldNumber_Duration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMVideoDescription__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMVideoDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMVideoDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMVoteChoice

@implementation ZTMVoteChoice

@dynamic title;
@dynamic votes;
@dynamic img;

typedef struct ZTMVoteChoice__storage_ {
  uint32_t _has_storage_[1];
  int32_t votes;
  NSString *title;
  NSString *img;
} ZTMVoteChoice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVoteChoice_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMVoteChoice__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "votes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVoteChoice_FieldNumber_Votes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMVoteChoice__storage_, votes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = ZTMVoteChoice_FieldNumber_Img,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMVoteChoice__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMVoteChoice class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMVoteChoice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelDescription

@implementation ZTMChannelDescription

@dynamic id_p;
@dynamic category;
@dynamic userId;
@dynamic name;
@dynamic icon;
@dynamic description_p;
@dynamic isActive;
@dynamic isVerify;
@dynamic isRecommend;
@dynamic isAnonymous;
@dynamic createAt;
@dynamic updateAt;
@dynamic senseCount;
@dynamic subscribeTimes;
@dynamic updateDescAt;
@dynamic lastPostAt;

typedef struct ZTMChannelDescription__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  int32_t isActive;
  int32_t isVerify;
  int32_t isRecommend;
  int32_t isAnonymous;
  uint32_t createAt;
  uint32_t updateAt;
  int32_t senseCount;
  int32_t subscribeTimes;
  uint32_t updateDescAt;
  uint32_t lastPostAt;
  NSString *id_p;
  NSString *userId;
  NSString *name;
  NSString *icon;
  NSString *description_p;
} ZTMChannelDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_Description_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_IsActive,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isVerify",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_IsVerify,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, isVerify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isRecommend",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_IsRecommend,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, isRecommend),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAnonymous",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_IsAnonymous,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, isAnonymous),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_CreateAt,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "updateAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_UpdateAt,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, updateAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "senseCount",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_SenseCount,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, senseCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subscribeTimes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_SubscribeTimes,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, subscribeTimes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "updateDescAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_UpdateDescAt,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, updateDescAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "lastPostAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelDescription_FieldNumber_LastPostAt,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMChannelDescription__storage_, lastPostAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\003\006\000\010\010\000\t\010\000\n\013\000\013\013\000\014\010\000\r\010\000\016\n\000\017\016\000\020\014\000\021\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelPermission

@implementation ZTMChannelPermission

@dynamic post;
@dynamic subscribe;
@dynamic share;
@dynamic manage;

typedef struct ZTMChannelPermission__storage_ {
  uint32_t _has_storage_[1];
  int32_t post;
  int32_t subscribe;
  int32_t share;
  int32_t manage;
} ZTMChannelPermission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "post",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelPermission_FieldNumber_Post,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMChannelPermission__storage_, post),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subscribe",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelPermission_FieldNumber_Subscribe,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMChannelPermission__storage_, subscribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "share",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelPermission_FieldNumber_Share,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMChannelPermission__storage_, share),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "manage",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelPermission_FieldNumber_Manage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMChannelPermission__storage_, manage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelPermission class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelPermission__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSenseDescription

@implementation ZTMSenseDescription

@dynamic id_p;
@dynamic category;
@dynamic channelId;
@dynamic userId;
@dynamic createAt;
@dynamic updateAt;
@dynamic isFolded;
@dynamic isActive;
@dynamic likes;
@dynamic views;
@dynamic punchTimes;

typedef struct ZTMSenseDescription__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  uint32_t createAt;
  uint32_t updateAt;
  int32_t isFolded;
  int32_t isActive;
  int32_t likes;
  int32_t views;
  int32_t punchTimes;
  NSString *id_p;
  NSString *channelId;
  NSString *userId;
} ZTMSenseDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_ChannelId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, channelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_CreateAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "updateAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_UpdateAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, updateAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "isFolded",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_IsFolded,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, isFolded),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_IsActive,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "likes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_Likes,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, likes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "views",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_Views,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, views),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "punchTimes",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSenseDescription_FieldNumber_PunchTimes,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMSenseDescription__storage_, punchTimes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSenseDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSenseDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\003\t\000\004\006\000\005\010\000\006\010\000\007\010\000\010\010\000\013\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSensePermission

@implementation ZTMSensePermission

@dynamic ignore;
@dynamic fold;
@dynamic indict;
@dynamic delete_p;
@dynamic markAsSpam;

typedef struct ZTMSensePermission__storage_ {
  uint32_t _has_storage_[1];
  int32_t ignore;
  int32_t fold;
  int32_t indict;
  int32_t delete_p;
  int32_t markAsSpam;
} ZTMSensePermission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ignore",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSensePermission_FieldNumber_Ignore,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSensePermission__storage_, ignore),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fold",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSensePermission_FieldNumber_Fold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSensePermission__storage_, fold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "indict",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSensePermission_FieldNumber_Indict,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMSensePermission__storage_, indict),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "delete_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSensePermission_FieldNumber_Delete_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMSensePermission__storage_, delete_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "markAsSpam",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSensePermission_FieldNumber_MarkAsSpam,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMSensePermission__storage_, markAsSpam),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSensePermission class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSensePermission__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMConfigurationSplash

@implementation ZTMConfigurationSplash

@dynamic URL;
@dynamic style;
@dynamic duration;
@dynamic time;
@dynamic isNeedLogin;
@dynamic isFirstOpen;
@dynamic appVersion;

typedef struct ZTMConfigurationSplash__storage_ {
  uint32_t _has_storage_[1];
  int32_t duration;
  int32_t isNeedLogin;
  int32_t isFirstOpen;
  NSString *URL;
  NSString *style;
  NSString *time;
  NSString *appVersion;
} ZTMConfigurationSplash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationSplash_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMConfigurationSplash__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "style",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationSplash_FieldNumber_Style,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMConfigurationSplash__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationSplash_FieldNumber_Duration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMConfigurationSplash__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationSplash_FieldNumber_Time,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMConfigurationSplash__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isNeedLogin",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationSplash_FieldNumber_IsNeedLogin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMConfigurationSplash__storage_, isNeedLogin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isFirstOpen",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationSplash_FieldNumber_IsFirstOpen,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMConfigurationSplash__storage_, isFirstOpen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationSplash_FieldNumber_AppVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMConfigurationSplash__storage_, appVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMConfigurationSplash class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMConfigurationSplash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001!!!\000\005\013\000\006\013\000\007\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMConfigurationTab

@implementation ZTMConfigurationTab

@dynamic URL;
@dynamic style;
@dynamic title;
@dynamic icon;
@dynamic selectedIcon;
@dynamic isSelected;

typedef struct ZTMConfigurationTab__storage_ {
  uint32_t _has_storage_[1];
  int32_t isSelected;
  NSString *URL;
  NSString *style;
  NSString *title;
  NSString *icon;
  NSString *selectedIcon;
} ZTMConfigurationTab__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationTab_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMConfigurationTab__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "style",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationTab_FieldNumber_Style,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMConfigurationTab__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationTab_FieldNumber_Title,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMConfigurationTab__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationTab_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMConfigurationTab__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selectedIcon",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationTab_FieldNumber_SelectedIcon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMConfigurationTab__storage_, selectedIcon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isSelected",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationTab_FieldNumber_IsSelected,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMConfigurationTab__storage_, isSelected),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMConfigurationTab class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMConfigurationTab__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001!!!\000\005\014\000\006\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMConfigurationUrlDomain

@implementation ZTMConfigurationUrlDomain

@dynamic api;
@dynamic apiScheme;
@dynamic apiUrlsArray, apiUrlsArray_Count;
@dynamic im;
@dynamic imScheme;
@dynamic imUrlsArray, imUrlsArray_Count;
@dynamic storage;
@dynamic storageScheme;
@dynamic storageUrlsArray, storageUrlsArray_Count;
@dynamic bucket;
@dynamic bucketEndPoint;

typedef struct ZTMConfigurationUrlDomain__storage_ {
  uint32_t _has_storage_[1];
  NSString *api;
  NSString *apiScheme;
  NSMutableArray *apiUrlsArray;
  NSString *im;
  NSString *imScheme;
  NSMutableArray *imUrlsArray;
  NSString *storage;
  NSString *storageScheme;
  NSMutableArray *storageUrlsArray;
  NSString *bucket;
  NSString *bucketEndPoint;
} ZTMConfigurationUrlDomain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "api",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_Api,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, api),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "apiScheme",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_ApiScheme,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, apiScheme),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "apiUrlsArray",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_ApiUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, apiUrlsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "im",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_Im,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, im),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imScheme",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_ImScheme,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, imScheme),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imUrlsArray",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_ImUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, imUrlsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storage",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_Storage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, storage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storageScheme",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_StorageScheme,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, storageScheme),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storageUrlsArray",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_StorageUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, storageUrlsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bucket",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_Bucket,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, bucket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bucketEndPoint",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationUrlDomain_FieldNumber_BucketEndPoint,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMConfigurationUrlDomain__storage_, bucketEndPoint),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMConfigurationUrlDomain class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMConfigurationUrlDomain__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\002\t\000\003\000apiUrls\000\005\010\000\006\000imUrls\000\010\r\000\t\000storageUr"
        "ls\000\013\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMConfigurationVersion

@implementation ZTMConfigurationVersion

@dynamic supportVersion;
@dynamic lastVersion;
@dynamic lastVersionName;
@dynamic lastVersionURL;
@dynamic lastVersionMessage;

typedef struct ZTMConfigurationVersion__storage_ {
  uint32_t _has_storage_[1];
  int32_t supportVersion;
  int32_t lastVersion;
  NSString *lastVersionName;
  NSString *lastVersionURL;
  NSString *lastVersionMessage;
} ZTMConfigurationVersion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "supportVersion",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationVersion_FieldNumber_SupportVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMConfigurationVersion__storage_, supportVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastVersion",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationVersion_FieldNumber_LastVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMConfigurationVersion__storage_, lastVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastVersionName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationVersion_FieldNumber_LastVersionName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMConfigurationVersion__storage_, lastVersionName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastVersionURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationVersion_FieldNumber_LastVersionURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMConfigurationVersion__storage_, lastVersionURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastVersionMessage",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConfigurationVersion_FieldNumber_LastVersionMessage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMConfigurationVersion__storage_, lastVersionMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMConfigurationVersion class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMConfigurationVersion__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\016\000\002\013\000\003\017\000\004\014!!\000\005\022\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMDiscoveryTheme

@implementation ZTMDiscoveryTheme

@dynamic id_p;
@dynamic title;
@dynamic img;
@dynamic URL;
@dynamic style;
@dynamic rule;

typedef struct ZTMDiscoveryTheme__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *title;
  NSString *img;
  NSString *URL;
  NSString *style;
  NSString *rule;
} ZTMDiscoveryTheme__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryTheme_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMDiscoveryTheme__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryTheme_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMDiscoveryTheme__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryTheme_FieldNumber_Img,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMDiscoveryTheme__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryTheme_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMDiscoveryTheme__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "style",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryTheme_FieldNumber_Style,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMDiscoveryTheme__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rule",
        .dataTypeSpecific.className = NULL,
        .number = ZTMDiscoveryTheme_FieldNumber_Rule,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMDiscoveryTheme__storage_, rule),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMDiscoveryTheme class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMDiscoveryTheme__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMRegionDescription

@implementation ZTMRegionDescription

@dynamic name;
@dynamic pinyin;

typedef struct ZTMRegionDescription__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *pinyin;
} ZTMRegionDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ZTMRegionDescription_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMRegionDescription__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pinyin",
        .dataTypeSpecific.className = NULL,
        .number = ZTMRegionDescription_FieldNumber_Pinyin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMRegionDescription__storage_, pinyin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMRegionDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMRegionDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMReplyDescription

@implementation ZTMReplyDescription

@dynamic id_p;
@dynamic createAt;
@dynamic targetType;
@dynamic content;
@dynamic userId;
@dynamic replyToId;
@dynamic replyToUserId;
@dynamic targetId;
@dynamic targetUserId;
@dynamic targetParentId;
@dynamic targetParentUserId;
@dynamic contentType;
@dynamic contentLength;
@dynamic totalPraises;

typedef struct ZTMReplyDescription__storage_ {
  uint32_t _has_storage_[1];
  uint32_t createAt;
  NSString *id_p;
  NSString *targetType;
  NSString *content;
  NSString *userId;
  NSString *replyToId;
  NSString *replyToUserId;
  NSString *targetId;
  NSString *targetUserId;
  NSString *targetParentId;
  NSString *targetParentUserId;
  NSString *contentType;
  NSString *contentLength;
  NSString *totalPraises;
} ZTMReplyDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_CreateAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "targetType",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_TargetType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, targetType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_UserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyToId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_ReplyToId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, replyToId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyToUserId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_ReplyToUserId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, replyToUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_TargetId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetUserId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_TargetUserId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, targetUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetParentId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_TargetParentId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, targetParentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetParentUserId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_TargetParentUserId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, targetParentUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentType",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_ContentType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, contentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentLength",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_ContentLength,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, contentLength),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalPraises",
        .dataTypeSpecific.className = NULL,
        .number = ZTMReplyDescription_FieldNumber_TotalPraises,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMReplyDescription__storage_, totalPraises),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMReplyDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMReplyDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\014\002\010\000\003\n\000\005\006\000\006\t\000\007\r\000\010\010\000\t\014\000\n\016\000\013\022\000\014\013\000\r\r\000\016\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMUserDescription

@implementation ZTMUserDescription

@dynamic id_p;
@dynamic userName;
@dynamic avatar;
@dynamic isActive;
@dynamic sex;
@dynamic createAt;
@dynamic cityCode;
@dynamic timeZone;
@dynamic tokenServer;
@dynamic tel;
@dynamic openId;
@dynamic isStaff;
@dynamic isAgreeOwnerNotice;

typedef struct ZTMUserDescription__storage_ {
  uint32_t _has_storage_[1];
  int32_t isActive;
  int32_t sex;
  uint32_t createAt;
  int32_t isStaff;
  int32_t isAgreeOwnerNotice;
  NSString *id_p;
  NSString *userName;
  NSString *avatar;
  NSString *cityCode;
  NSString *timeZone;
  NSString *tokenServer;
  NSString *tel;
  NSString *openId;
} ZTMUserDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_IsActive,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, isActive),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_CreateAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "cityCode",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_CityCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, cityCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_TimeZone,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokenServer",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_TokenServer,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, tokenServer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tel",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_Tel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, tel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "openId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_OpenId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, openId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isStaff",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_IsStaff,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, isStaff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAgreeOwnerNotice",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserDescription_FieldNumber_IsAgreeOwnerNotice,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMUserDescription__storage_, isAgreeOwnerNotice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMUserDescription class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMUserDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\002\010\000\004\010\000\006\010\000\007\010\000\010\010\000\t\013\000\013\006\000\014\007\000\r\022\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSticker

@implementation ZTMSticker

@dynamic id_p;
@dynamic URL;
@dynamic meaning;
@dynamic isLiked;

typedef struct ZTMSticker__storage_ {
  uint32_t _has_storage_[1];
  int32_t isLiked;
  NSString *id_p;
  NSString *URL;
  NSString *meaning;
} ZTMSticker__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSticker_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSticker__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSticker_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSticker__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meaning",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSticker_FieldNumber_Meaning,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMSticker__storage_, meaning),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isLiked",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSticker_FieldNumber_IsLiked,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMSticker__storage_, isLiked),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSticker class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSticker__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002!!!\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSharingMessage

@implementation ZTMSharingMessage

@dynamic shareId;
@dynamic URL;
@dynamic wbMsg;
@dynamic wbImg;
@dynamic wbURL;
@dynamic wbShortURL;
@dynamic wxTitle;
@dynamic wxSubtitle;
@dynamic wxURL;
@dynamic pyqTitle;
@dynamic pyqSubtitle;
@dynamic pyqURL;
@dynamic qqTitle;
@dynamic qqSubtitle;
@dynamic qqURL;
@dynamic qzoneTitle;
@dynamic qzoneURL;
@dynamic thumbnail;
@dynamic mediaURL;

typedef struct ZTMSharingMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *shareId;
  NSString *URL;
  NSString *wbMsg;
  NSString *wbImg;
  NSString *wbURL;
  NSString *wbShortURL;
  NSString *wxTitle;
  NSString *wxSubtitle;
  NSString *wxURL;
  NSString *pyqTitle;
  NSString *pyqSubtitle;
  NSString *pyqURL;
  NSString *qqTitle;
  NSString *qqSubtitle;
  NSString *qqURL;
  NSString *qzoneTitle;
  NSString *qzoneURL;
  NSString *thumbnail;
  NSString *mediaURL;
} ZTMSharingMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shareId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_ShareId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, shareId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wbMsg",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_WbMsg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, wbMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wbImg",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_WbImg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, wbImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wbURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_WbURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, wbURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wbShortURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_WbShortURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, wbShortURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wxTitle",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_WxTitle,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, wxTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wxSubtitle",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_WxSubtitle,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, wxSubtitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wxURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_WxURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, wxURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pyqTitle",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_PyqTitle,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, pyqTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pyqSubtitle",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_PyqSubtitle,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, pyqSubtitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pyqURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_PyqURL,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, pyqURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qqTitle",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_QqTitle,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, qqTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qqSubtitle",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_QqSubtitle,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, qqSubtitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qqURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_QqURL,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, qqURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qzoneTitle",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_QzoneTitle,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, qzoneTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qzoneURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_QzoneURL,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, qzoneURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumbnail",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_Thumbnail,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, thumbnail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediaURL",
        .dataTypeSpecific.className = NULL,
        .number = ZTMSharingMessage_FieldNumber_MediaURL,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ZTMSharingMessage__storage_, mediaURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSharingMessage class]
                                     rootClass:[ZTMPlainRoot class]
                                          file:ZTMPlainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSharingMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\022\001\007\000\002!!!\000\003\005\000\004\005\000\005\003!!\000\006\010!!\000\007\007\000\010\n\000\t\003!!\000\n\010\000\013"
        "\013\000\014\004!!\000\r\007\000\016\n\000\017\003!!\000\020\n\000\021\006!!\000\023\006!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
