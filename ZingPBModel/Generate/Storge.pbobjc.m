// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: storge.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Storge.pbobjc.h"
 #import "Plain.pbobjc.h"
 #import "Composite.pbobjc.h"
 #import "Response.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ZTMStorgeRoot

@implementation ZTMStorgeRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ZTMStorgeRoot_FileDescriptor

static GPBFileDescriptor *ZTMStorgeRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"zing.model.storge"
                                                 objcPrefix:@"ZTM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ZTMAttachment

@implementation ZTMAttachment

@dynamic path;
@dynamic size;
@dynamic id_p;
@dynamic uploadedSize;
@dynamic isUploaded;

typedef struct ZTMAttachment__storage_ {
  uint32_t _has_storage_[1];
  int32_t isUploaded;
  NSString *path;
  NSString *id_p;
  int64_t size;
  int64_t uploadedSize;
} ZTMAttachment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAttachment_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMAttachment__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAttachment_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMAttachment__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAttachment_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMAttachment__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uploadedSize",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAttachment_FieldNumber_UploadedSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMAttachment__storage_, uploadedSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isUploaded",
        .dataTypeSpecific.className = NULL,
        .number = ZTMAttachment_FieldNumber_IsUploaded,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ZTMAttachment__storage_, isUploaded),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMAttachment class]
                                     rootClass:[ZTMStorgeRoot class]
                                          file:ZTMStorgeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMAttachment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\014\000\005\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMLocalProfile

@implementation ZTMLocalProfile

@dynamic userId;
@dynamic version;
@dynamic users, users_Count;

typedef struct ZTMLocalProfile__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  NSString *userId;
  NSMutableDictionary *users;
} ZTMLocalProfile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ZTMLocalProfile_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMLocalProfile__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = ZTMLocalProfile_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMLocalProfile__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "users",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMLocalProfile_FieldNumber_Users,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMLocalProfile__storage_, users),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMLocalProfile class]
                                     rootClass:[ZTMStorgeRoot class]
                                          file:ZTMStorgeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMLocalProfile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMUserLocalProfile

@implementation ZTMUserLocalProfile

@dynamic tokenServer;
@dynamic channelProfiles, channelProfiles_Count;
@dynamic hasBlacklist, blacklist;
@dynamic conversationProfiles, conversationProfiles_Count;
@dynamic hasUser, user;
@dynamic recommendAttitude;

typedef struct ZTMUserLocalProfile__storage_ {
  uint32_t _has_storage_[1];
  NSString *tokenServer;
  NSMutableDictionary *channelProfiles;
  ZTMBlacklist *blacklist;
  NSMutableDictionary *conversationProfiles;
  ZTMUserDescription *user;
  NSString *recommendAttitude;
} ZTMUserLocalProfile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenServer",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserLocalProfile_FieldNumber_TokenServer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMUserLocalProfile__storage_, tokenServer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelProfiles",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMChannelLocalProfile),
        .number = ZTMUserLocalProfile_FieldNumber_ChannelProfiles,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMUserLocalProfile__storage_, channelProfiles),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blacklist",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMBlacklist),
        .number = ZTMUserLocalProfile_FieldNumber_Blacklist,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMUserLocalProfile__storage_, blacklist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conversationProfiles",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMConversationLocalProfile),
        .number = ZTMUserLocalProfile_FieldNumber_ConversationProfiles,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMUserLocalProfile__storage_, conversationProfiles),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMUserDescription),
        .number = ZTMUserLocalProfile_FieldNumber_User,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMUserLocalProfile__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recommendAttitude",
        .dataTypeSpecific.className = NULL,
        .number = ZTMUserLocalProfile_FieldNumber_RecommendAttitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMUserLocalProfile__storage_, recommendAttitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMUserLocalProfile class]
                                     rootClass:[ZTMStorgeRoot class]
                                          file:ZTMStorgeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMUserLocalProfile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\013\000\002\017\000\004\024\000\006\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMChannelLocalProfile

@implementation ZTMChannelLocalProfile

@dynamic indictedSensesArray, indictedSensesArray_Count;
@dynamic drafts, drafts_Count;

typedef struct ZTMChannelLocalProfile__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *indictedSensesArray;
  NSMutableDictionary *drafts;
} ZTMChannelLocalProfile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "indictedSensesArray",
        .dataTypeSpecific.className = NULL,
        .number = ZTMChannelLocalProfile_FieldNumber_IndictedSensesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMChannelLocalProfile__storage_, indictedSensesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "drafts",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSenseDraft),
        .number = ZTMChannelLocalProfile_FieldNumber_Drafts,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMChannelLocalProfile__storage_, drafts),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMChannelLocalProfile class]
                                     rootClass:[ZTMStorgeRoot class]
                                          file:ZTMStorgeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMChannelLocalProfile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000indictedSenses\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMSenseDraft

@implementation ZTMSenseDraft

@dynamic hasSense, sense;
@dynamic attachmentsArray, attachmentsArray_Count;

typedef struct ZTMSenseDraft__storage_ {
  uint32_t _has_storage_[1];
  ZTMSense *sense;
  NSMutableArray *attachmentsArray;
} ZTMSenseDraft__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sense",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMSense),
        .number = ZTMSenseDraft_FieldNumber_Sense,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMSenseDraft__storage_, sense),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachmentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMAttachment),
        .number = ZTMSenseDraft_FieldNumber_AttachmentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMSenseDraft__storage_, attachmentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMSenseDraft class]
                                     rootClass:[ZTMStorgeRoot class]
                                          file:ZTMStorgeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMSenseDraft__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMConversationLocalProfile

@implementation ZTMConversationLocalProfile

@dynamic drafts, drafts_Count;
@dynamic unread;
@dynamic readedSpeach, readedSpeach_Count;

typedef struct ZTMConversationLocalProfile__storage_ {
  uint32_t _has_storage_[1];
  int32_t unread;
  GPBUInt32ObjectDictionary *drafts;
  GPBStringUInt32Dictionary *readedSpeach;
} ZTMConversationLocalProfile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "drafts",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMConversationDraft),
        .number = ZTMConversationLocalProfile_FieldNumber_Drafts,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMConversationLocalProfile__storage_, drafts),
        .flags = GPBFieldMapKeyFixed32,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unread",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConversationLocalProfile_FieldNumber_Unread,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMConversationLocalProfile__storage_, unread),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "readedSpeach",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConversationLocalProfile_FieldNumber_ReadedSpeach,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZTMConversationLocalProfile__storage_, readedSpeach),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMConversationLocalProfile class]
                                     rootClass:[ZTMStorgeRoot class]
                                          file:ZTMStorgeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMConversationLocalProfile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZTMConversationDraft

@implementation ZTMConversationDraft

@dynamic createAt;
@dynamic isSended;
@dynamic hasMessage, message;
@dynamic hasAttachment, attachment;

typedef struct ZTMConversationDraft__storage_ {
  uint32_t _has_storage_[1];
  uint32_t createAt;
  int32_t isSended;
  ZTMTalkMessage *message;
  ZTMAttachment *attachment;
} ZTMConversationDraft__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConversationDraft_FieldNumber_CreateAt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZTMConversationDraft__storage_, createAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "isSended",
        .dataTypeSpecific.className = NULL,
        .number = ZTMConversationDraft_FieldNumber_IsSended,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZTMConversationDraft__storage_, isSended),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMTalkMessage),
        .number = ZTMConversationDraft_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZTMConversationDraft__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachment",
        .dataTypeSpecific.className = GPBStringifySymbol(ZTMAttachment),
        .number = ZTMConversationDraft_FieldNumber_Attachment,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ZTMConversationDraft__storage_, attachment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZTMConversationDraft class]
                                     rootClass:[ZTMStorgeRoot class]
                                          file:ZTMStorgeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZTMConversationDraft__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
